/**
 * saltyrtc-client-js v0.15.1
 * SaltyRTC JavaScript implementation
 * https://github.com/saltyrtc/saltyrtc-client-js
 *
 * Copyright (C) 2016-2022 Threema GmbH
 *
 * This software may be modified and distributed under the terms
 * of the MIT license:
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
"use strict";var saltyrtcClient=function(e,t,s){function r(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(s){if("default"!==s){var r=Object.getOwnPropertyDescriptor(e,s);Object.defineProperty(t,s,r.get?r:{enumerable:!0,get:function(){return e[s]}})}})),t.default=e,Object.freeze(t)}var i=r(t),n=r(s);class o{}function a(e){switch(e){case o.ClosingNormal:return"Normal closing";case o.GoingAway:return"The endpoint is going away";case o.NoSharedSubprotocol:return"No shared subprotocol could be found";case o.PathFull:return"No free responder byte";case o.ProtocolError:return"Protocol error";case o.InternalError:return"Internal error";case o.Handover:return"Handover finished";case o.DroppedByInitiator:return"Dropped by initiator";case o.InitiatorCouldNotDecrypt:return"Initiator could not decrypt a message";case o.NoSharedTask:return"No shared task was found";case o.InvalidKey:return"Invalid key";case o.Timeout:return"Timeout";default:return"Unknown"}}o.ClosingNormal=1e3,o.GoingAway=1001,o.NoSharedSubprotocol=1002,o.PathFull=3e3,o.ProtocolError=3001,o.InternalError=3002,o.Handover=3003,o.DroppedByInitiator=3004,o.InitiatorCouldNotDecrypt=3005,o.NoSharedTask=3006,o.InvalidKey=3007,o.Timeout=3008;class h extends Error{constructor(e,t){super(t),this.message=t,this.closeCode=e,this.name="SignalingError"}}class d extends h{constructor(e){super(o.ProtocolError,e)}}class c extends Error{constructor(e){super(e),this.message=e,this.name="ConnectionError"}}class l extends Error{constructor(e,t=!0){super(e),this.message=e,this.name="ValidationError",this.critical=t}}class g extends Error{constructor(e,t){super(t),this.name="CryptoError",this.message=t,this.code=e}}var u=Object.freeze({__proto__:null,SignalingError:h,ProtocolError:d,ConnectionError:c,ValidationError:l,CryptoError:g});class y{constructor(){this.map=new Map}register(e,t){if("string"==typeof e)this.set(e,t);else for(const s of e)this.set(s,t)}unregister(e,t){if("string"==typeof e){if(!this.map.has(e))return;if(void 0===t)this.map.delete(e);else{const s=this.map.get(e),r=s.indexOf(t);-1!==r&&s.splice(r,1)}}else for(const s of e)this.unregister(s,t)}unregisterAll(){this.map.clear()}set(e,t){if(this.map.has(e)){const s=this.map.get(e);-1===s.indexOf(t)&&s.push(t)}else this.map.set(e,[t])}get(e){const t=[];if("string"==typeof e)this.map.has(e)&&t.push.apply(t,this.map.get(e));else for(const s of e)for(const e of this.get(s))-1===t.indexOf(e)&&t.push(e);return t}}class p{constructor(e){this.level=e}set level(e){switch(this._level=e,this.debug=this.noop,this.trace=this.noop,this.info=this.noop,this.warn=this.noop,this.error=this.noop,this.assert=this.noop,e){case"debug":this.debug=console.debug,this.trace=console.trace;case"info":this.info=console.info;case"warn":this.warn=console.warn;case"error":this.error=console.error,this.assert=console.assert}}get level(){return this._level}noop(){}}function w(e){const t=[];for(const s of e)t.push(s.toString(16).replace(/^([\da-f])$/,"0$1"));return t.join("")}function k(e){return"0x"+("00"+e.toString(16)).substr(-2)}function f(...e){let t=0;for(const s of e)t+=s.length;const s=new Uint8Array(t);let r=0;for(const t of e)s.set(t,r),r+=t.length;return s}function v(e,t="Key"){let s;if("string"==typeof(r=e)||r instanceof String){if(64!==e.length)throw new l(t+" must be 32 bytes long");s=function(e){let t,s,r,i,n=0;for(e.length%2==1&&(e="0"+e),t=new Uint8Array(e.length/2),s=r=0,i=e.length;r<=i;s=r+=2)t[n++]=parseInt(e.substr(s,2),16);return t}(e)}else{if(!(e instanceof Uint8Array))throw new l(t+" must be an Uint8Array or a hex string");s=e}var r;if(32!==s.byteLength)throw new l(t+" must be 32 bytes long");return s}function m(e){return 0===e.byteOffset&&e.byteLength===e.buffer.byteLength?e.buffer:e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength)}class b{constructor(e,t,s){this._nonce=e,this._nonceLength=s,this._data=t}get length(){return this._nonce.length+this._data.length}get data(){return this._data}get nonce(){return this._nonce}static fromUint8Array(e,t){if(void 0===t)throw new Error("nonceLength parameter not specified");if(e.byteLength<=t)throw new g("bad-message-length","Message is shorter than nonce");const s=e.slice(0,t),r=e.slice(t);return new b(s,r,t)}toUint8Array(){const e=new Uint8Array(this.length);return e.set(this._nonce),e.set(this._data,this._nonceLength),e}}class T{constructor(e,t){if(this.logTag="[SaltyRTC.KeyStore]",void 0===t&&(t=new p("none")),arguments.length>2)throw new Error("Too many arguments in KeyStore constructor");void 0===e?(this._keyPair=i.box.keyPair(),t.debug(this.logTag,"New public key:",w(this._keyPair.publicKey))):(this._keyPair=i.box.keyPair.fromSecretKey(v(e,"Private key")),t.debug(this.logTag,"Restored public key:",w(this._keyPair.publicKey)))}getSharedKeyStore(e){return new S(this.secretKeyBytes,e)}get publicKeyHex(){return w(this._keyPair.publicKey)}get publicKeyBytes(){return this._keyPair.publicKey}get secretKeyHex(){return w(this._keyPair.secretKey)}get secretKeyBytes(){return this._keyPair.secretKey}get keypair(){return this._keyPair}encryptRaw(e,t,s){return i.box(e,t,s,this._keyPair.secretKey)}encrypt(e,t,s){const r=this.encryptRaw(e,t,s);return new b(t,r,i.box.nonceLength)}decryptRaw(e,t,s){const r=i.box.open(e,t,s,this._keyPair.secretKey);if(!r)throw new g("decryption-failed","Data could not be decrypted");return r}decrypt(e,t){return this.decryptRaw(e.data,e.nonce,t)}}class S{constructor(e,t){this._localSecretKey=v(e,"Local private key"),this._remotePublicKey=v(t,"Remote public key"),this._sharedKey=i.box.before(this._remotePublicKey,this._localSecretKey)}get localSecretKeyHex(){return w(this._localSecretKey)}get localSecretKeyBytes(){return this._localSecretKey}get remotePublicKeyHex(){return w(this._remotePublicKey)}get remotePublicKeyBytes(){return this._remotePublicKey}encryptRaw(e,t){return i.box.after(e,t,this._sharedKey)}encrypt(e,t){const s=this.encryptRaw(e,t);return new b(t,s,i.box.nonceLength)}decryptRaw(e,t){const s=i.box.open.after(e,t,this._sharedKey);if(!s)throw new g("decryption-failed","Data could not be decrypted");return s}decrypt(e){return this.decryptRaw(e.data,e.nonce)}}class K{constructor(e,t){if(this._authToken=null,this.logTag="[SaltyRTC.AuthToken]",void 0===t&&(t=new p("none")),void 0===e)this._authToken=i.randomBytes(i.secretbox.keyLength),t.debug(this.logTag,"Generated auth token");else{if(e.byteLength!==i.secretbox.keyLength){const e="Auth token must be "+i.secretbox.keyLength+" bytes long.";throw t.error(this.logTag,e),new g("bad-token-length",e)}this._authToken=e,t.debug(this.logTag,"Initialized auth token")}}get keyBytes(){return this._authToken}get keyHex(){return w(this._authToken)}encrypt(e,t){const s=i.secretbox(e,t,this._authToken);return new b(t,s,i.secretbox.nonceLength)}decrypt(e){const t=i.secretbox.open(e.data,e.nonce,this._authToken);if(!t)throw new g("decryption-failed","Data could not be decrypted");return t}}class _{constructor(e){if(void 0!==e){if(16!==e.length)throw new l("Bad cookie length");this.bytes=e}else this.bytes=i.randomBytes(_.COOKIE_LENGTH)}equals(e){if(e.bytes===this.bytes)return!0;if(e.bytes.byteLength!==_.COOKIE_LENGTH)return!1;for(let t=0;t<this.bytes.byteLength;t++)if(e.bytes[t]!==this.bytes[t])return!1;return!0}}_.COOKIE_LENGTH=16;class R{constructor(e,t){if(this._ours=null,this._theirs=null,void 0!==e&&void 0!==t){if(t.equals(e))throw new d("Their cookie matches our cookie");this._ours=e,this._theirs=t}else{if(void 0!==e||void 0!==t)throw new Error("Either both or no cookies must be specified");this._ours=new _}}static fromTheirs(e){let t;do{t=new _}while(t.equals(e));return new R(t,e)}get ours(){return this._ours}get theirs(){return this._theirs}set theirs(e){if(e.equals(this._ours))throw new d("Their cookie matches our cookie");this._theirs=e}}class P{constructor(e,t,s,r,i){this._cookie=e,this._overflow=t,this._sequenceNumber=s,this._source=r,this._destination=i}get cookie(){return this._cookie}get overflow(){return this._overflow}get sequenceNumber(){return this._sequenceNumber}get combinedSequenceNumber(){return this._overflow*Math.pow(2,32)+this._sequenceNumber}get source(){return this._source}get destination(){return this._destination}static fromUint8Array(e){if(e.byteLength!==this.TOTAL_LENGTH)throw new l("bad-packet-length");const t=new DataView(e.buffer,e.byteOffset+_.COOKIE_LENGTH,8),s=new _(e.slice(0,_.COOKIE_LENGTH)),r=t.getUint8(0),i=t.getUint8(1),n=t.getUint16(2),o=t.getUint32(4);return new P(s,n,o,r,i)}toUint8Array(){const e=new ArrayBuffer(P.TOTAL_LENGTH),t=new Uint8Array(e);t.set(this._cookie.bytes);const s=new DataView(e,_.COOKIE_LENGTH,8);return s.setUint8(0,this._source),s.setUint8(1,this._destination),s.setUint16(2,this._overflow),s.setUint32(4,this._sequenceNumber),t}}P.TOTAL_LENGTH=24;class C{constructor(){this.sequenceNumber=(window.crypto||window.msCrypto).getRandomValues(new Uint32Array(1))[0],this.overflow=0}next(){if(this.sequenceNumber>=C.SEQUENCE_NUMBER_MAX){if(this.sequenceNumber=0,this.overflow+=1,this.overflow>=C.OVERFLOW_MAX)throw new Error("overflow-overflow")}else this.sequenceNumber+=1;return{sequenceNumber:this.sequenceNumber,overflow:this.overflow}}asNumber(){return this.overflow*Math.pow(2,32)+this.sequenceNumber}}C.SEQUENCE_NUMBER_MAX=4294967295,C.OVERFLOW_MAX=1048575;class E{constructor(e,t){if(this.ours=null,this.theirs=null,void 0!==e&&void 0!==t)this.ours=e,this.theirs=t;else{if(void 0!==e||void 0!==t)throw new Error("Either both or no combined sequences must be specified");this.ours=new C}}}class I{constructor(e,t){this._csnPair=new E,this._permanentSharedKey=null,this._sessionSharedKey=null,this._id=e,this._cookiePair=void 0===t?new R:t}get id(){return this._id}get hexId(){return k(this._id)}get csnPair(){return this._csnPair}get cookiePair(){return this._cookiePair}get permanentSharedKey(){return this._permanentSharedKey}get sessionSharedKey(){return this._sessionSharedKey}setPermanentSharedKey(e,t){this._permanentSharedKey=t.getSharedKeyStore(e)}setSessionSharedKey(e,t){this._sessionSharedKey=t.getSharedKeyStore(e)}}class A extends I{constructor(){super(...arguments),this._localSessionKey=null}get localSessionKey(){return this._localSessionKey}setLocalSessionKey(e){this._localSessionKey=e}setSessionSharedKey(e,t){t?this._localSessionKey=t:t=this._localSessionKey,super.setSessionSharedKey(e,t)}}class N extends A{constructor(e,t){super(N.ID),this.connected=!1,this.handshakeState="new",this.setPermanentSharedKey(e,t)}get name(){return"Initiator"}}N.ID=1;class D extends A{constructor(e,t){super(e),this.handshakeState="new",this._counter=t}get name(){return"Responder "+this.id}get counter(){return this._counter}}class L extends I{constructor(){super(L.ID),this.handshakeState="new"}get name(){return"Server"}}L.ID=0;class O{constructor(){this.reset()}get local(){return this._local}set local(e){const t=this.both;this._local=e,!t&&this.both&&void 0!==this.onBoth&&this.onBoth()}get peer(){return this._peer}set peer(e){const t=this.both;this._peer=e,!t&&this.both&&void 0!==this.onBoth&&this.onBoth()}get both(){return!0===this._local&&!0===this._peer}get any(){return!0===this._local||!0===this._peer}reset(){this._local=!1,this._peer=!1}}function x(e){return e>=2&&e<=255}class U{constructor(e,t,s,r,i,a,h,d){this.protocol="wss",this.ws=null,this.msgpackEncodeOptions={codec:n.createCodec({binarraybuffer:!0})},this.msgpackDecodeOptions={codec:n.createCodec({binarraybuffer:!0})},this.state="new",this.handoverState=new O,this.neverConnected=!0,this.task=null,this.server=new L,this.peerTrustedKey=null,this.authToken=null,this.serverPublicKey=null,this.role=null,this.logTag="[SaltyRTC.Signaling]",this.address=U.SALTYRTC_ADDR_UNKNOWN,this.log=e.log,this.client=e,this.permanentKey=h,this.host=t,this.port=s,this.tasks=i,this.pingInterval=a,void 0!==d&&(this.peerTrustedKey=d),void 0!==r&&(this.serverPublicKey=r),this.handoverState.onBoth=()=>{this.client.emit({type:"handover"}),this.closeWebsocket(o.Handover)}}setState(e){this.state=e,this.client.emit({type:"state-change",data:e}),this.client.emit({type:"state-change:"+e})}getState(){return this.state}get permanentKeyBytes(){return this.permanentKey.publicKeyBytes}get authTokenBytes(){return null!==this.authToken?this.authToken.keyBytes:null}get peerPermanentKeyBytes(){return this.getPeer().permanentSharedKey.remotePublicKeyBytes}msgpackEncode(e){return n.encode(e,this.msgpackEncodeOptions)}msgpackDecode(e){return n.decode(e,this.msgpackDecodeOptions)}connect(){if(!0!==this.neverConnected)throw new c("Signaling instance cannot be reused. Please create a new client instance.");this.neverConnected=!1,this.resetConnection(),this.initWebsocket()}disconnect(e=!1){const t=o.ClosingNormal;this.setState("closing"),"task"===this.state&&this.sendClose(t),this.closeWebsocket(t,void 0,e),null!==this.task&&(this.log.debug(this.logTag,"Closing task connections"),this.task.close(t)),this.setState("closed")}closeWebsocket(e,t,s=!1){null!==this.ws&&((void 0===e||e<=3e3)&&(e=o.ClosingNormal),this.log.debug(this.logTag,`Disconnecting WebSocket, close code: ${e}`),this.ws.close(e,t),s&&(this.ws.removeEventListener("open",this.onOpen.bind(this)),this.ws.removeEventListener("error",this.onError.bind(this)),this.ws.removeEventListener("close",this.onClose.bind(this)),this.ws.removeEventListener("message",this.onMessage.bind(this))),this.ws=null,s&&this.setState("closed"))}initWebsocket(){const e=this.protocol+"://"+this.host+":"+this.port+"/",t=this.getWebsocketPath();this.ws=new WebSocket(e+t,U.SALTYRTC_SUBPROTOCOL),this.ws.binaryType="arraybuffer",this.ws.addEventListener("open",this.onOpen.bind(this)),this.ws.addEventListener("error",this.onError.bind(this)),this.ws.addEventListener("close",this.onClose.bind(this)),this.ws.addEventListener("message",this.onMessage.bind(this)),this.setState("ws-connecting"),this.log.debug(this.logTag,"Opening WebSocket connection to",e+t)}onOpen(){this.log.info(this.logTag,"Opened connection"),this.setState("server-handshake")}onError(e){this.log.error(this.logTag,"General WebSocket error",e),this.client.emit({type:"connection-error"})}onClose(e){e.code===o.Handover?this.log.info(this.logTag,"Closed WebSocket connection due to handover"):(this.log.info(this.logTag,"Closed WebSocket connection with close code "+e.code+" ("+a(e.code)+")"),this.setState("closed"),this.client.emit({type:"connection-closed",data:e.code}))}onMessage(e){if(this.log.debug(this.logTag,"New ws message ("+e.data.byteLength+" bytes)"),this.handoverState.peer)return this.log.error(this.logTag,"Protocol error: Received WebSocket message from peer even though it has already handed over to task."),void this.resetConnection(o.ProtocolError);let t;try{const s=b.fromUint8Array(new Uint8Array(e.data),P.TOTAL_LENGTH);t=P.fromUint8Array(s.nonce);if(null===this.getPeerWithId(t.source))return void this.log.debug(this.logTag,"Ignoring message from unknown id: "+t.source);try{this.validateNonce(t)}catch(e){if("ValidationError"===e.name){if(!0===e.critical)throw new d("Invalid nonce: "+e);return void this.log.warn(this.logTag,"Dropping message with invalid nonce: "+e)}throw e}switch(this.getState()){case"server-handshake":this.onServerHandshakeMessage(s,t);break;case"peer-handshake":this.onPeerHandshakeMessage(s,t);break;case"task":this.onSignalingMessage(s,t);break;default:this.log.warn(this.logTag,"Received message in",this.getState(),"signaling state. Ignoring.")}}catch(e){if("SignalingError"===e.name||"ProtocolError"===e.name){let s="Signaling error: "+a(e.closeCode);switch(e.message&&(s+=" ("+e.message+")"),this.log.error(this.logTag,s),this.state){case"new":case"ws-connecting":case"server-handshake":this.resetConnection(e.closeCode);break;case"peer-handshake":this.handlePeerHandshakeSignalingError(e,void 0===t?null:t.source);break;case"task":this.sendClose(e.closeCode),this.resetConnection(o.ClosingNormal)}}else{if("ConnectionError"!==e.name)throw e.hasOwnProperty("stack")&&(this.log.error(this.logTag,"An unknown error occurred:"),this.log.error(e.stack)),e;this.log.warn(this.logTag,"Connection error. Resetting connection."),this.resetConnection(o.InternalError)}}}onServerHandshakeMessage(e,t){let s;s="new"===this.server.handshakeState?e.data:this.server.sessionSharedKey.decrypt(e);const r=this.decodeMessage(s,"server handshake");switch(this.server.handshakeState){case"new":if("server-hello"!==r.type)throw new d("Expected server-hello message, but got "+r.type);this.log.debug(this.logTag,"Received server-hello"),this.handleServerHello(r,t),this.sendClientHello(),this.sendClientAuth();break;case"hello-sent":throw new d("Received "+r.type+" message before sending client-auth");case"auth-sent":if("server-auth"!==r.type)throw new d("Expected server-auth message, but got "+r.type);this.log.debug(this.logTag,"Received server-auth"),this.handleServerAuth(r,t);break;case"done":throw new h(o.InternalError,"Received server handshake message even though server handshake state is set to 'done'");default:throw new h(o.InternalError,"Unknown server handshake state: "+this.server.handshakeState)}"done"===this.server.handshakeState&&(this.setState("peer-handshake"),this.log.debug(this.logTag,"Server handshake done"),this.initPeerHandshake())}onSignalingMessage(e,t){if(this.log.debug(this.logTag,"Message received"),t.source===U.SALTYRTC_ADDR_SERVER)this.onSignalingServerMessage(e);else{const t=this.getPeer().sessionSharedKey.decrypt(e);this.onSignalingPeerMessage(t)}}onSignalingServerMessage(e){const t=this.decryptServerMessage(e);switch(t.type){case"send-error":this.log.debug(this.logTag,"Received send-error message"),this.handleSendError(t);break;case"disconnected":this.log.debug(this.logTag,"Received disconnected message"),this.handleDisconnected(t);break;default:this.onUnhandledSignalingServerMessage(t)}}onSignalingPeerMessage(e){const t=this.decodeMessage(e);if("close"===t.type)this.log.debug(this.logTag,"Received close"),this.handleClose(t);else if("application"===t.type)this.log.debug(this.logTag,"Received application message"),this.handleApplication(t);else if(null!==this.task){-1!==this.task.getSupportedMessageTypes().indexOf(t.type)?(this.log.debug(this.logTag,"Received",t.type,"["+this.task.getName()+"]"),this.task.onTaskMessage(t)):(this.log.error(this.logTag,"Received",t.type,"message which is not supported by the",this.task.getName(),"task"),this.resetConnection(o.ProtocolError))}else this.log.warn(this.logTag,"Received message with invalid type from peer:",t.type)}handleServerHello(e,t){this.server.setSessionSharedKey(new Uint8Array(e.key),this.permanentKey),this.server.cookiePair.theirs=t.cookie}sendClientAuth(){const e={type:"client-auth",your_cookie:m(this.server.cookiePair.theirs.bytes),subprotocols:[U.SALTYRTC_SUBPROTOCOL],ping_interval:this.pingInterval};null!==this.serverPublicKey&&(e.your_key=m(this.serverPublicKey));const t=this.buildPacket(e,this.server);this.log.debug(this.logTag,"Sending client-auth"),this.ws.send(t),this.server.handshakeState="auth-sent"}handleSendError(e){const t=new DataView(e.id),s=w(new Uint8Array(e.id)),r=t.getUint8(0),i=t.getUint8(1);if(r!==this.address)throw new d("Received send-error message for a message not sent by us!");this.log.warn(this.logTag,"SendError: Could not send unknown message:",s),this._handleSendError(i)}handleApplication(e){this.client.emit({type:"application",data:e.data})}sendClose(e){const t={type:"close",reason:e};if(this.log.debug(this.logTag,"Sending close"),!0===this.handoverState.local)this.task.sendSignalingMessage(this.msgpackEncode(t));else{const e=this.buildPacket(t,this.getPeer());this.ws.send(e)}}handleClose(e){this.log.warn(this.logTag,"Received close message. Reason:",e.reason,"("+a(e.reason)+")"),this.task.close(e.reason),this.resetConnection(o.GoingAway)}handleDisconnected(e){this.client.emit({type:"peer-disconnected",data:e.id})}validateNonce(e){this.validateNonceSource(e),this.validateNonceDestination(e),this.validateNonceCsn(e),this.validateNonceCookie(e)}validateNonceSource(e){switch(this.state){case"server-handshake":if(e.source!==U.SALTYRTC_ADDR_SERVER)throw new l("Received message during server handshake with invalid sender address ("+e.source+" != "+U.SALTYRTC_ADDR_SERVER+")",!1);break;case"peer-handshake":case"task":if(e.source!==U.SALTYRTC_ADDR_SERVER){if("initiator"===this.role&&!x(e.source))throw new l("Initiator peer message does not come from a valid responder address: "+e.source,!1);if("responder"===this.role&&e.source!==U.SALTYRTC_ADDR_INITIATOR)throw new l("Responder peer message does not come from intitiator ("+U.SALTYRTC_ADDR_INITIATOR+"), but from "+e.source,!1)}break;default:throw new d("Cannot validate message nonce in signaling state "+this.state)}}validateNonceDestination(e){let t=null;if("server-handshake"===this.state)switch(this.server.handshakeState){case"new":case"hello-sent":t=U.SALTYRTC_ADDR_UNKNOWN;break;case"auth-sent":if("initiator"===this.role)t=U.SALTYRTC_ADDR_INITIATOR;else if(!x(e.destination))throw new l("Received message during server handshake with invalid receiver address ("+e.destination+" is not a valid responder id)");break;case"done":t=this.address}else{if("peer-handshake"!==this.state&&"task"!==this.state)throw new l("Cannot validate message nonce in signaling state "+this.state);t=this.address}if(null!==t&&e.destination!==t)throw new l("Received message with invalid destination ("+e.destination+" != "+t+")")}validateNonceCsn(e){const t=this.getPeerWithId(e.source);if(null===t)throw new d("Could not find peer "+e.source);if(null===t.csnPair.theirs){if(0!==e.overflow)throw new l("First message from "+t.name+" must have set the overflow number to 0");t.csnPair.theirs=e.combinedSequenceNumber}else{const s=t.csnPair.theirs,r=e.combinedSequenceNumber;if(r<s)throw new l(t.name+" CSN is lower than last time");if(r===s)throw new l(t.name+" CSN hasn't been incremented");t.csnPair.theirs=r}}validateNonceCookie(e){const t=this.getPeerWithId(e.source);if(null!==t&&null!==t.cookiePair.theirs&&!e.cookie.equals(t.cookiePair.theirs))throw new l(t.name+" cookie changed")}validateRepeatedCookie(e,t){const s=new _(t);if(!s.equals(e.cookiePair.ours))throw this.log.debug(this.logTag,"Their cookie:",s.bytes),this.log.debug(this.logTag,"Our cookie:",e.cookiePair.ours.bytes),new d("Peer repeated cookie does not match our cookie")}validateSignedKeys(e,t,s){if(null==e)throw new l("Server did not send signed_keys in server-auth message");const r=new b(t.toUint8Array(),new Uint8Array(e),i.box.nonceLength);let n;this.log.debug(this.logTag,"Expected server public permanent key is",w(s));try{n=this.permanentKey.decrypt(r,s)}catch(e){if("CryptoError"===e.name&&"decryption-failed"===e.code)throw new l("Could not decrypt signed_keys in server_auth message");throw e}if(!function(e,t){if(e.length!==t.length)return!1;for(let s=0;s<e.length;s++)if(e[s]!==t[s])return!1;return!0}(n,f(this.server.sessionSharedKey.remotePublicKeyBytes,this.permanentKey.publicKeyBytes)))throw new l("Decrypted signed_keys in server-auth message is invalid")}decodeMessage(e,t,s=!1){const r=this.msgpackDecode(e);if(void 0===r.type)throw new d("Malformed "+t+" message: Failed to decode msgpack data.");if(s&&void 0!==t&&r.type!==t)throw new d("Invalid "+t+" message, bad type: "+r);return r}buildPacket(e,t,s=!0){let r;try{r=t.csnPair.ours.next()}catch(e){throw new d("CSN overflow: "+e.message)}const i=new P(t.cookiePair.ours,r.overflow,r.sequenceNumber,this.address,t.id).toUint8Array(),n=this.msgpackEncode(e);if(!1===s)return f(i,n);let o;if(t.id===U.SALTYRTC_ADDR_SERVER)o=this.encryptHandshakeDataForServer(n,i);else{if(t.id!==U.SALTYRTC_ADDR_INITIATOR&&!x(t.id))throw new d("Bad receiver byte: "+t);o=this.encryptHandshakeDataForPeer(t.id,e.type,n,i)}return o.toUint8Array()}encryptHandshakeDataForServer(e,t){return this.server.sessionSharedKey.encrypt(e,t)}getCurrentPeerCsn(){return"task"!==this.getState()?null:{incoming:this.getPeer().csnPair.theirs,outgoing:this.getPeer().csnPair.ours.asNumber()}}decryptData(e){return this.getPeer().sessionSharedKey.decrypt(e)}resetConnection(e){this.closeWebsocket(e,void 0,!0),this.server=new L,this.handoverState.reset(),this.setState("new"),void 0!==e&&this.log.debug(this.logTag,"Connection reset")}initTask(e,t){try{e.init(this,t)}catch(e){if("ValidationError"===e.name)throw new d("Peer sent invalid task data");throw e}this.task=e}decryptPeerMessage(e,t=!0){try{const t=this.getPeer().sessionSharedKey.decrypt(e);return this.decodeMessage(t,"peer")}catch(s){if(!0===t&&"CryptoError"===s.name&&"decryption-failed"===s.code){const t=P.fromUint8Array(e.nonce);throw new d("Could not decrypt peer message from "+k(t.source))}throw s}}decryptServerMessage(e){try{const t=this.server.sessionSharedKey.decrypt(e);return this.decodeMessage(t,"server")}catch(e){throw"CryptoError"===e.name&&"decryption-failed"===e.code?new d("Could not decrypt server message"):e}}sendApplication(e){this.sendPostClientHandshakeMessage(e,"application")}sendTaskMessage(e){this.sendPostClientHandshakeMessage(e,"task")}sendPostClientHandshakeMessage(e,t){if("task"!==this.state)throw new h(o.ProtocolError,"Cannot send "+t+' message in "'+this.state+'" state');const s=this.getPeer();if(null===s)throw new h(o.InternalError,"No peer address could be found");if(!0===this.handoverState.local)this.log.debug(this.logTag,"Sending",t,"message through dc"),this.task.sendSignalingMessage(this.msgpackEncode(e));else{this.log.debug(this.logTag,"Sending",t,"message through ws");const r=this.buildPacket(e,s);this.ws.send(r)}}encryptForPeer(e,t){const s=this.getPeer();if(!s)throw new Error("Remote peer has not yet been established");const r=s.sessionSharedKey;if(!r)throw new Error("Session key not yet established");return r.encrypt(e,t)}decryptFromPeer(e){const t=this.getPeer();if(!t)throw new Error("Remote peer has not yet been established");const s=t.sessionSharedKey;if(!s)throw new Error("Session key not yet established");try{return s.decrypt(e)}catch(e){throw"CryptoError"===e.name&&"decryption-failed"===e.code?("task"===this.state&&this.sendClose(o.InternalError),this.resetConnection(o.InternalError),new h(o.InternalError,"Decryption of peer message failed. This should not happen.")):e}}}U.SALTYRTC_SUBPROTOCOL="v1.saltyrtc.org",U.SALTYRTC_ADDR_UNKNOWN=0,U.SALTYRTC_ADDR_SERVER=0,U.SALTYRTC_ADDR_INITIATOR=1;class M extends U{constructor(e,t,s,r,i,n,o,a){super(e,t,s,r,i,n,o,a),this.logTag="[SaltyRTC.Initiator]",this.responderCounter=0,this.responders=null,this.responder=null,this.role="initiator",void 0===a&&(this.authToken=new K(void 0,this.log))}getWebsocketPath(){return this.permanentKey.publicKeyHex}encryptHandshakeDataForPeer(e,t,s,r){if(e===U.SALTYRTC_ADDR_INITIATOR)throw new d("Initiator cannot encrypt messages for initiator");if(!x(e))throw new d("Bad receiver byte: "+e);let i;if("task"===this.getState())i=this.responder;else{if(!this.responders.has(e))throw new d("Unknown responder: "+e);i=this.responders.get(e)}return"key"===t?i.permanentSharedKey.encrypt(s,r):i.sessionSharedKey.encrypt(s,r)}getPeer(){return null!==this.responder?this.responder:null}getPeerWithId(e){if(e===U.SALTYRTC_ADDR_SERVER)return this.server;if(x(e))return"task"===this.state&&null!==this.responder&&this.responder.id===e?this.responder:this.responders.has(e)?this.responders.get(e):null;throw new d("Invalid peer id: "+e)}handlePeerHandshakeSignalingError(e,t){null!==t&&this.dropResponder(t,e.closeCode)}processNewResponder(e){this.responders.has(e)&&(this.log.warn(this.logTag,`Previous responder discarded (server should have sent 'disconnected' message): ${e}`),this.responders.delete(e));const t=new D(e,this.responderCounter++);null!==this.peerTrustedKey&&(t.handshakeState="token-received",t.setPermanentSharedKey(this.peerTrustedKey,this.permanentKey)),this.responders.set(e,t),this.responders.size>252&&this.dropOldestInactiveResponder(),this.client.emit({type:"new-responder",data:e})}dropOldestInactiveResponder(){this.log.warn(this.logTag,"Dropping oldest inactive responder");let e=null;for(const t of this.responders.values())"new"===t.handshakeState&&(null===e||t.counter<e.counter)&&(e=t);null!==e&&this.dropResponder(e.id,o.DroppedByInitiator)}onPeerHandshakeMessage(e,t){if(t.destination!==this.address)throw new d("Message destination does not match our address");let s;if(t.source===U.SALTYRTC_ADDR_SERVER){try{s=this.server.sessionSharedKey.decrypt(e)}catch(e){throw"CryptoError"===e.name&&"decryption-failed"===e.code?new h(o.ProtocolError,"Could not decrypt server message."):e}const t=this.decodeMessage(s,"server");switch(t.type){case"new-responder":this.log.debug(this.logTag,"Received new-responder message",k(t.id)),this.handleNewResponder(t);break;case"send-error":this.log.debug(this.logTag,"Received send-error message"),this.handleSendError(t);break;case"disconnected":this.log.debug(this.logTag,"Received disconnected message"),this.handleDisconnected(t);break;default:throw new d("Received unexpected server message: "+t.type)}}else{if(!x(t.source))throw new h(o.InternalError,"Message source is neither the server nor a responder");{const r=this.responders.get(t.source);if(null===r)throw new d("Unknown message source: "+t.source);let i;switch(r.handshakeState){case"new":if(null!==this.peerTrustedKey)throw new h(o.InternalError,'Handshake state is "new" even though a trusted key is available');try{s=this.authToken.decrypt(e)}catch(e){return this.log.warn(this.logTag,"Could not decrypt token message: ",e),void this.dropResponder(r.id,o.InitiatorCouldNotDecrypt)}i=this.decodeMessage(s,"token",!0),this.log.debug(this.logTag,"Received token"),this.handleToken(i,r);break;case"token-received":if(null!==this.peerTrustedKey)try{s=this.permanentKey.decrypt(e,this.peerTrustedKey)}catch(e){return this.log.warn(this.logTag,"Could not decrypt key message"),void this.dropResponder(r.id,o.InitiatorCouldNotDecrypt)}else s=r.permanentSharedKey.decrypt(e);i=this.decodeMessage(s,"key",!0),this.log.debug(this.logTag,"Received key"),this.handleKey(i,r),this.sendKey(r);break;case"key-sent":try{s=r.sessionSharedKey.decrypt(e)}catch(e){throw"CryptoError"===e.name&&"decryption-failed"===e.code?new h(o.ProtocolError,"Could not decrypt auth message."):e}i=this.decodeMessage(s,"auth",!0),this.log.debug(this.logTag,"Received auth"),this.handleAuth(i,r,t),this.sendAuth(r,t),this.responder=this.responders.get(r.id),this.responders.delete(r.id),this.dropResponders(o.DroppedByInitiator),this.setState("task"),this.log.info(this.logTag,"Peer handshake done"),this.task.onPeerHandshakeDone();break;default:throw new h(o.InternalError,"Unknown responder handshake state")}}}}onUnhandledSignalingServerMessage(e){"new-responder"===e.type?(this.log.debug(this.logTag,"Received new-responder message"),this.handleNewResponder(e)):this.log.warn(this.logTag,"Unexpected server message type:",e.type)}sendClientHello(){}handleServerAuth(e,t){if(this.address=U.SALTYRTC_ADDR_INITIATOR,this.validateRepeatedCookie(this.server,new Uint8Array(e.your_cookie)),null!=this.serverPublicKey)try{this.validateSignedKeys(new Uint8Array(e.signed_keys),t,this.serverPublicKey)}catch(e){if("ValidationError"===e.name)throw new d("Verification of signed_keys failed: "+e.message);throw e}else null!==e.signed_keys&&void 0!==e.signed_keys&&this.log.warn(this.logTag,"Server sent signed keys, but we're not verifying them.");this.responders=new Map;for(const t of e.responders){if(!x(t))throw new d("Responder id "+t+" must be in the range 0x02-0xff");this.processNewResponder(t)}this.log.debug(this.logTag,this.responders.size,"responders connected"),this.server.handshakeState="done"}initPeerHandshake(){}handleNewResponder(e){if(!x(e.id))throw new d("Responder id "+e.id+" must be in the range 0x02-0xff");"peer-handshake"===this.state?this.processNewResponder(e.id):(this.log.debug(this.logTag,`Dropping responder ${e.id} in '${this.state}' state`),this.dropResponder(e.id,o.DroppedByInitiator))}handleToken(e,t){t.setPermanentSharedKey(new Uint8Array(e.key),this.permanentKey),t.handshakeState="token-received"}handleKey(e,t){t.setLocalSessionKey(new T(void 0,this.log)),t.setSessionSharedKey(new Uint8Array(e.key)),t.handshakeState="key-received"}sendKey(e){const t={type:"key",key:m(e.localSessionKey.publicKeyBytes)},s=this.buildPacket(t,e);this.log.debug(this.logTag,"Sending key"),this.ws.send(s),e.handshakeState="key-sent"}sendAuth(e,t){if(t.cookie.equals(e.cookiePair.ours))throw new d("Their cookie and our cookie are the same.");const s={};s[this.task.getName()]=this.task.getData();const r={type:"auth",your_cookie:m(t.cookie.bytes),task:this.task.getName(),data:s},i=this.buildPacket(r,e);this.log.debug(this.logTag,"Sending auth"),this.ws.send(i),e.handshakeState="auth-sent"}handleAuth(e,t,s){this.validateRepeatedCookie(t,new Uint8Array(e.your_cookie));try{M.validateTaskInfo(e.tasks,e.data)}catch(e){if("ValidationError"===e.name)throw new d("Peer sent invalid task info: "+e.message);throw e}const r=M.chooseCommonTask(this.tasks,e.tasks);if(null===r){const t=this.tasks.map((e=>e.getName())),s=e.tasks;throw this.log.debug(this.logTag,"We requested:",t,"Peer offered:",s),this.client.emit({type:"no-shared-task",data:{requested:t,offered:s}}),new h(o.NoSharedTask,"No shared task could be found")}this.log.debug(this.logTag,"Task",r.getName(),"has been selected"),this.initTask(r,e.data[r.getName()]),this.log.debug(this.logTag,"Responder",t.hexId,"authenticated"),t.cookiePair.theirs=s.cookie,t.handshakeState="auth-received"}static validateTaskInfo(e,t){if(e.length<1)throw new l("Task names must not be empty");if(Object.keys(t).length<1)throw new l("Task data must not be empty");if(e.length!==Object.keys(t).length)throw new l("Task data must contain an entry for every task");for(const s of e)if(!t.hasOwnProperty(s))throw new l("Task data must contain an entry for every task")}static chooseCommonTask(e,t){for(const s of e)if(-1!==t.indexOf(s.getName()))return s;return null}_handleSendError(e){if(!x(e))throw new d("Outgoing c2c messages must have been sent to a responder");let t=!1;if(null===this.responder){const s=this.responders.get(e);null==s?this.log.warn(this.logTag,"Got send-error message for unknown responder",e):(t=!0,this.responders.delete(e))}else this.responder.id===e?(t=!0,this.resetConnection(o.ProtocolError)):this.log.warn(this.logTag,"Got send-error message for unknown responder",e);!0===t&&this.client.emit({type:"signaling-connection-lost",data:e})}dropResponders(e){this.log.debug(this.logTag,"Dropping",this.responders.size,"other responders.");for(const t of this.responders.keys())this.dropResponder(t,e)}dropResponder(e,t){const s={type:"drop-responder",id:e,reason:t},r=this.buildPacket(s,this.server);this.log.debug(this.logTag,"Sending drop-responder",k(e)),this.ws.send(r),this.responders.delete(e)}}class H extends U{constructor(e,t,s,r,i,n,o,a,h){super(e,t,s,r,i,n,o,void 0===h?a:void 0),this.logTag="[SaltyRTC.Responder]",this.initiator=null,this.role="responder",this.initiator=new N(a,this.permanentKey),void 0!==h?this.authToken=h:this.initiator.handshakeState="token-sent"}getWebsocketPath(){return this.initiator.permanentSharedKey.remotePublicKeyHex}encryptHandshakeDataForPeer(e,t,s,r){if(x(e))throw new d("Responder may not encrypt messages for other responders: "+e);if(e!==U.SALTYRTC_ADDR_INITIATOR)throw new d("Bad receiver byte: "+e);switch(t){case"token":return this.authToken.encrypt(s,r);case"key":return this.initiator.permanentSharedKey.encrypt(s,r);default:const e=this.getPeer().sessionSharedKey;if(null===e)throw new d("Trying to encrypt for peer using session key, but session key is null");return e.encrypt(s,r)}}getPeer(){return null!==this.initiator?this.initiator:null}getPeerWithId(e){if(e===U.SALTYRTC_ADDR_SERVER)return this.server;if(e===U.SALTYRTC_ADDR_INITIATOR)return this.initiator;throw new d("Invalid peer id: "+e)}handlePeerHandshakeSignalingError(e,t){this.resetConnection(e.closeCode)}onPeerHandshakeMessage(e,t){if(t.destination!==this.address)throw new d("Message destination does not match our address");let s;if(t.source===U.SALTYRTC_ADDR_SERVER){try{s=this.server.sessionSharedKey.decrypt(e)}catch(e){throw"CryptoError"===e.name&&"decryption-failed"===e.code?new h(o.ProtocolError,"Could not decrypt server message."):e}const t=this.decodeMessage(s,"server");switch(t.type){case"new-initiator":this.log.debug(this.logTag,"Received new-initiator message"),this.handleNewInitiator();break;case"send-error":this.log.debug(this.logTag,"Received send-error message"),this.handleSendError(t);break;case"disconnected":this.log.debug(this.logTag,"Received disconnected message"),this.handleDisconnected(t);break;default:throw new d("Received unexpected server message: "+t.type)}}else{if(t.source!==U.SALTYRTC_ADDR_INITIATOR)throw new h(o.InternalError,"Message source is neither the server nor the initiator");{let r;switch(s=this.decryptInitiatorMessage(e),this.initiator.handshakeState){case"new":throw new d("Unexpected peer handshake message");case"key-sent":r=this.decodeMessage(s,"key",!0),this.log.debug(this.logTag,"Received key"),this.handleKey(r),this.sendAuth(t);break;case"auth-sent":r=this.decodeMessage(s,"auth",!0),this.log.debug(this.logTag,"Received auth"),this.handleAuth(r,t),this.setState("task"),this.log.info(this.logTag,"Peer handshake done");break;default:throw new h(o.InternalError,"Unknown initiator handshake state")}}}}decryptInitiatorMessage(e){switch(this.initiator.handshakeState){case"new":case"token-sent":case"key-received":throw new d("Received message in "+this.initiator.handshakeState+" state.");case"key-sent":try{return this.initiator.permanentSharedKey.decrypt(e)}catch(e){throw"CryptoError"===e.name&&"decryption-failed"===e.code?new h(o.ProtocolError,"Could not decrypt key message."):e}case"auth-sent":case"auth-received":try{return this.initiator.sessionSharedKey.decrypt(e)}catch(e){throw"CryptoError"===e.name&&"decryption-failed"===e.code?new h(o.ProtocolError,"Could not decrypt initiator session message."):e}default:throw new d("Invalid handshake state: "+this.initiator.handshakeState)}}onUnhandledSignalingServerMessage(e){"new-initiator"===e.type?(this.log.debug(this.logTag,"Received new-initiator message after peer handshake completed, closing"),this.resetConnection(o.ClosingNormal)):this.log.warn(this.logTag,"Unexpected server message type:",e.type)}sendClientHello(){const e={type:"client-hello",key:m(this.permanentKey.publicKeyBytes)},t=this.buildPacket(e,this.server,!1);this.log.debug(this.logTag,"Sending client-hello"),this.ws.send(t),this.server.handshakeState="hello-sent"}handleServerAuth(e,t){if(t.destination>255||t.destination<2)throw this.log.error(this.logTag,"Invalid nonce destination:",t.destination),new l("Invalid nonce destination: "+t.destination);if(this.address=t.destination,this.log.debug(this.logTag,"Server assigned address",k(this.address)),this.logTag="[SaltyRTC.Responder."+k(this.address)+"]",this.validateRepeatedCookie(this.server,new Uint8Array(e.your_cookie)),null!=this.serverPublicKey)try{this.validateSignedKeys(new Uint8Array(e.signed_keys),t,this.serverPublicKey)}catch(e){if("ValidationError"===e.name)throw new d("Verification of signed_keys failed: "+e.message);throw e}else null!==e.signed_keys&&void 0!==e.signed_keys&&this.log.warn(this.logTag,"Server sent signed keys, but we're not verifying them.");this.initiator.connected=e.initiator_connected,this.log.debug(this.logTag,"Initiator",this.initiator.connected?"":"not","connected"),this.server.handshakeState="done"}handleNewInitiator(){this.initiator=new N(this.initiator.permanentSharedKey.remotePublicKeyBytes,this.permanentKey),this.initiator.connected=!0,this.initPeerHandshake()}initPeerHandshake(){this.initiator.connected&&(null===this.peerTrustedKey&&this.sendToken(),this.sendKey())}sendToken(){const e={type:"token",key:m(this.permanentKey.publicKeyBytes)},t=this.buildPacket(e,this.initiator);this.log.debug(this.logTag,"Sending token"),this.ws.send(t),this.initiator.handshakeState="token-sent"}sendKey(){this.initiator.setLocalSessionKey(new T(void 0,this.log));const e={type:"key",key:m(this.initiator.localSessionKey.publicKeyBytes)},t=this.buildPacket(e,this.initiator);this.log.debug(this.logTag,"Sending key"),this.ws.send(t),this.initiator.handshakeState="key-sent"}handleKey(e){this.initiator.setSessionSharedKey(new Uint8Array(e.key)),this.initiator.handshakeState="key-received"}sendAuth(e){if(e.cookie.equals(this.initiator.cookiePair.ours))throw new d("Their cookie and our cookie are the same.");const t={};for(const e of this.tasks)t[e.getName()]=e.getData();const s=this.tasks.map((e=>e.getName())),r={type:"auth",your_cookie:m(e.cookie.bytes),tasks:s,data:t},i=this.buildPacket(r,this.initiator);this.log.debug(this.logTag,"Sending auth"),this.ws.send(i),this.initiator.handshakeState="auth-sent"}handleAuth(e,t){this.validateRepeatedCookie(this.initiator,new Uint8Array(e.your_cookie));try{H.validateTaskInfo(e.task,e.data)}catch(e){if("ValidationError"===e.name)throw new d("Peer sent invalid task info: "+e.message);throw e}let s=null;for(const t of this.tasks)if(t.getName()===e.task){s=t,this.log.info(this.logTag,"Task",e.task,"has been selected");break}if(null===s)throw new h(o.ProtocolError,"Initiator selected unknown task");this.initTask(s,e.data[s.getName()]),this.log.debug(this.logTag,"Initiator authenticated"),this.initiator.cookiePair.theirs=t.cookie,this.initiator.handshakeState="auth-received"}static validateTaskInfo(e,t){if(0===e.length)throw new l("Task name must not be empty");if(Object.keys(t).length<1)throw new l("Task data must not be empty");if(Object.keys(t).length>1)throw new l("Task data must contain exactly 1 key");if(!t.hasOwnProperty(e))throw new l("Task data must contain an entry for the chosen task")}_handleSendError(e){if(e!==U.SALTYRTC_ADDR_INITIATOR)throw new d("Outgoing c2c messages must have been sent to the initiator");this.client.emit({type:"signaling-connection-lost",data:e}),this.resetConnection(o.ProtocolError)}}class B{constructor(){this.hasConnectionInfo=!1,this.hasKeyStore=!1,this.hasInitiatorInfo=!1,this.hasTrustedPeerKey=!1,this.hasTasks=!1,this.serverInfoFactory=null,this.pingInterval=0,this.logLevel="none"}static validateHost(e){if(e.endsWith("/"))throw new Error("SaltyRTC host may not end with a slash");if(-1!==e.indexOf("//"))throw new Error("SaltyRTC host should not contain protocol")}requireKeyStore(){if(!this.hasKeyStore)throw new Error("Keys not set yet. Please call .withKeyStore method first.")}requireConnectionInfo(){if(!this.hasConnectionInfo)throw new Error("Connection info not set yet. Please call .connectTo method first.")}requireTasks(){if(!this.hasTasks)throw new Error("Tasks not set yet. Please call .usingTasks method first.")}requireInitiatorInfo(){if(!this.hasInitiatorInfo)throw new Error("Initiator info not set yet. Please call .initiatorInfo method first.")}connectTo(e,t=8765){return B.validateHost(e),this.host=e,this.port=t,this.hasConnectionInfo=!0,this}connectWith(e){return this.serverInfoFactory=e,this.hasConnectionInfo=!0,this}withKeyStore(e){return this.keyStore=e,this.hasKeyStore=!0,this}withTrustedPeerKey(e){return this.peerTrustedKey=v(e,"SaltyRTC peer key"),this.hasTrustedPeerKey=!0,this}usingTasks(e){if(e.length<1)throw new Error("You must specify at least 1 task");return this.tasks=e,this.hasTasks=!0,this}withPingInterval(e){if(e<0)throw new Error("Ping interval may not be negative");return this.pingInterval=e,this}withServerKey(e){return this.serverPublicKey=v(e,"SaltyRTC server public key"),this}withLoggingLevel(e){return this.logLevel=e,this}initiatorInfo(e,t){return this.initiatorPublicKey=v(e,"SaltyRTC initiator public key"),this.authToken=v(t,"SaltyRTC auth token"),this.hasInitiatorInfo=!0,this}processServerInfo(e,t){const s=e(w(t));this.host=s.host,this.port=s.port}asInitiator(){if(this.requireConnectionInfo(),this.requireKeyStore(),this.requireTasks(),this.hasInitiatorInfo)throw new Error("Cannot initialize as initiator if .initiatorInfo(...) has been used");return null!==this.serverInfoFactory&&this.processServerInfo(this.serverInfoFactory,this.keyStore.publicKeyBytes),this.hasTrustedPeerKey?new q(new p(this.logLevel),this.keyStore,this.host,this.port,this.serverPublicKey,this.tasks,this.pingInterval,this.peerTrustedKey).asInitiator():new q(new p(this.logLevel),this.keyStore,this.host,this.port,this.serverPublicKey,this.tasks,this.pingInterval).asInitiator()}asResponder(){return this.requireConnectionInfo(),this.requireKeyStore(),this.requireTasks(),this.hasTrustedPeerKey?(null!==this.serverInfoFactory&&this.processServerInfo(this.serverInfoFactory,this.peerTrustedKey),new q(new p(this.logLevel),this.keyStore,this.host,this.port,this.serverPublicKey,this.tasks,this.pingInterval,this.peerTrustedKey).asResponder()):(this.requireInitiatorInfo(),null!==this.serverInfoFactory&&this.processServerInfo(this.serverInfoFactory,this.initiatorPublicKey),new q(new p(this.logLevel),this.keyStore,this.host,this.port,this.serverPublicKey,this.tasks,this.pingInterval).asResponder(this.initiatorPublicKey,this.authToken))}}class q{constructor(e,t,s,r,i,n,o,a){if(this.peerTrustedKey=null,this._signaling=null,this.logTag="[SaltyRTC.Client]",void 0===t)throw new Error("SaltyRTC must be initialized with a permanent key");if(void 0===s)throw new Error("SaltyRTC must be initialized with a target host");if(void 0===n||0===n.length)throw new Error("SaltyRTC must be initialized with at least 1 task");this.log=e,this.host=s,this.port=r,this.permanentKey=t,this.tasks=n,this.pingInterval=o,void 0!==a&&(this.peerTrustedKey=a),void 0!==i&&(this.serverPublicKey=i),this.eventRegistry=new y}asInitiator(){return null!==this.peerTrustedKey?this._signaling=new M(this,this.host,this.port,this.serverPublicKey,this.tasks,this.pingInterval,this.permanentKey,this.peerTrustedKey):this._signaling=new M(this,this.host,this.port,this.serverPublicKey,this.tasks,this.pingInterval,this.permanentKey),this}asResponder(e,t){if(null!==this.peerTrustedKey)this._signaling=new H(this,this.host,this.port,this.serverPublicKey,this.tasks,this.pingInterval,this.permanentKey,this.peerTrustedKey);else{const s=new K(t,this.log);this._signaling=new H(this,this.host,this.port,this.serverPublicKey,this.tasks,this.pingInterval,this.permanentKey,e,s)}return this}get signaling(){if(null===this._signaling)throw Error("SaltyRTC instance not initialized. Use .asInitiator() or .asResponder().");return this._signaling}get state(){return this.signaling.getState()}get keyStore(){return this.permanentKey}get permanentKeyBytes(){return this.signaling.permanentKeyBytes}get permanentKeyHex(){return w(this.signaling.permanentKeyBytes)}get authTokenBytes(){return this.signaling.authTokenBytes}get authTokenHex(){return this.signaling.authTokenBytes?w(this.signaling.authTokenBytes):null}get peerPermanentKeyBytes(){return this.signaling.peerPermanentKeyBytes}get peerPermanentKeyHex(){return w(this.signaling.peerPermanentKeyBytes)}getTask(){return this.signaling.task}getCurrentPeerCsn(){return this.signaling.getCurrentPeerCsn()}encryptForPeer(e,t){return this.signaling.encryptForPeer(e,t)}decryptFromPeer(e){return this.signaling.decryptFromPeer(e)}connect(){this.signaling.connect()}disconnect(e=!1){this.signaling.disconnect(e)}on(e,t){this.eventRegistry.register(e,t)}once(e,t){const s=e=>{try{t(e)}catch(t){throw this.off(e.type,s),t}this.off(e.type,s)};this.eventRegistry.register(e,s)}off(e,t){void 0===e?this.eventRegistry.unregisterAll():this.eventRegistry.unregister(e,t)}emit(e){this.log.debug(this.logTag,"New event:",e.type);const t=this.eventRegistry.get(e.type);for(const s of t)try{this.callHandler(s,e)}catch(t){this.log.error(this.logTag,"Unhandled exception in",e.type,"handler:",t)}}sendApplicationMessage(e){this.signaling.sendApplication({type:"application",data:e})}callHandler(e,t){!1===e(t)&&this.eventRegistry.unregister(t.type,e)}}return e.Box=b,e.CloseCode=o,e.CombinedSequence=C,e.CombinedSequencePair=E,e.ConnectionError=c,e.Cookie=_,e.CookiePair=R,e.EventRegistry=y,e.KeyStore=T,e.Log=p,e.SaltyRTCBuilder=B,e.SignalingError=h,e.exceptions=u,e.explainCloseCode=a,Object.defineProperty(e,"__esModule",{value:!0}),e}({},nacl,msgpack);
